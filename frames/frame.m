function F=frame(ftype,varargin);
%FRAME  Construct a new frame
%   Usage: F=frame(ftype,...);
%
%   `F=frame(ftype,...)` constructs a new frame object *F* of type
%   *ftype*. Arguments following *ftype* are specific to the type of frame
%   chosen.
%
%   Time/frequency frames
%   ---------------------
%
%   `frame('dgt',g,a,M)` constructs a Gabor frame with window *g*,
%   time-shift *a* and *M* channels. See the help on |dgt| for more
%   information.
%
%   `frame('dgtreal',g,a,M)` constructs a Gabor frame for real-valued
%   signals with window *g*, time-shift *a* and *M* channels. See the help
%   on |dgtreal| for more information.
%
%   `frame('dwilt',g,M)` constructs a Wilson basis with window *g* and *M*
%   channels. See the help on |dwilt| for more information.
%
%   `frame('wmdct',g,M)` constructs a windowed MDCT basis with window *g*
%   and *M* channels. See the help on |wmdct| for more information.
%
%   `frame('filterbank',g,a,M)` constructs a filterbank with filters *g*,
%   time-shifts of *a* and *M* channels. For the ease of implementation, it
%   is necessary to specify *M*, even though it strictly speaking could be
%   deduced from the size of the windows. See the help on |filterbank| for
%   more information on the parameters. Similarly, you can construct a
%   uniform filterbank by selecting `'ufilterbank'`, a positive-frequency
%   filterbank by selecting `'filterbankreal'` or a uniform
%   positive-frequency filterbank by selecting `'ufilterbankreal'`.
%
%   `frame('nsdgt',g,a,M)` constructs a non-stationary Gabor frame with
%   filters *g*, time-shifts of *a* and *M* channels. See the help on
%   |nsdgt| for more information on the parameters. Similarly, you can
%   construct a uniform NSDGT by selecting `'unsdgt'`, an NSDGT for
%   real-valued signals only by selecting `'nsdgtreal'` or a
%   uniform NSDGT for real-valued signals by selecting `'unsdgtreal'`.
%
%   Pure frequency frames
%   ---------------------
%
%   `frame('dft')` constructs a bais where the analysis operator is the
%   |dft|, and the synthesis operator is its inverse, |idft|. Completely
%   similar to this, you can enter the name of any of the cosine or sine
%   transforms |dcti|, |dctii|, |dctiii|, |dctiv|, |dsti|, |dstii|,
%   |dstiii| or |dstiv|.
%
%   `frame('dftreal')` constructs a normalized |fftreal| basis for
%   real-valued signals of even length only. The basis is normalized the
%   |dft| to ensure that is it orthonormal.
%
%   Special / general frames
%   ------------------------
%
%   `frame('gen',g)` constructs an general frame with analysis matrix *g*.
%   The frame atoms must be stored as column vectors in the matrices.
%
%   `frame('identity')` constructs the canonical orthornormal basis, meaning
%   that all operators return their input as output, so it is the dummy
%   operation.
%
%   `frame('randn',red,seed)` constructs a frame with redundancy *red*
%   constisting of random noise generated by `randn`. The optional parameter
%   *seed* specifies the initial seed for the noise generation. All frame
%   vectors are normalized to have unit energy / $l^2$-norm.
%
%   Container frames
%   ----------------
%
%   `frame('fusion',w,F1,F2,...)` constructs a fusion frame, which is
%   the collection of the frames specified by *F1*, *F2*,... The vector
%   *w* contains a weight for each frame. If *w* is a scalar, this weight
%   will be applied to all the sub-frames.
%
%   `frame('tensor',F1,F2,...)` constructs a tensor product frame, where the
%   frames *F1, *F2*,... are applied along the 1st, 2nd etc. dimensions. If
%   you don't want any action along a specific dimension, use the `identity`
%   frame along that dimension. Any remaining dimensions in the input
%   signal are left alone.
%  
%   Examples
%   --------
%
%   The following example creates a Gabor frame for real-valued signals,
%   analyses an input signal and plots the frame coefficients:::
%
%      F=frame('wmdct','gauss',40);
%      c=frana(F,greasy);
%      plotframe(F,c);
%
%   See also: frana, frsyn, plotframe

  
if nargin<1
  error('%s: Too few input parameters.',upper(mfilename));
end;

if ~ischar(ftype)
  error(['%s: First agument must be a string denoting the type of ' ...
         'frame.'],upper(mfilename));
end;

ftype=lower(ftype);

% True if the frame only works with real-valued input.
F.realinput=0;

% Handle the windowed transforms
switch(ftype)
 case {'dgt','dwilt','wmdct','filterbank','ufilterbank',...
       'nsdgt','unsdgt'}
  F.g=varargin{1};
  
 case {'dgtreal','filterbankreal','ufilterbankreal',...
      'nsdgtreal','unsdgtreal'}
  F.g=varargin{1};
  F.realinput=1;
  
end;

% For parsing optional parameters to the transforms.
vargs={};
definput=struct();

% Note to future developer / self: Only frames that do not require any
% parameters can express their analysis/synthesis operator as an anonynous
% function. It does not work, because the parameters get bound when F.frana
% gets created and not when it is called. This makes it impossible to change
% the other fields in F, for instance to instantiate a new window for a new
% signal length, breaking "frameaccel", or for "framedual" or
% "frametight" to return 


%% ---- Pre-optional parameters
% Common operations to deal with the input parameters.

switch(ftype)
  case {'dgt','dgtreal'}
    F.a=varargin{2};
    F.M=varargin{3};
    
    vargs=varargin(4:end);
    definput.keyvals.lt=[0 1];
    definput.flags.phase={'freqinv','timeinv'};    

  case {'dwilt','wmdct'}
    F.M=varargin{2};
  case {'filterbank','ufilterbank','filterbankreal','ufilterbankreal'}
    F.a=varargin{2};
    F.M=varargin{3};
    
    % Sanitize 'a': Make it a column vector of length M
    F.a=bsxfun(@times,F.a(:),ones(F.M,1));
    
  case {'nsdgt','unsdgt','nsdgtreal','unsdgtreal'}
    F.a=varargin{2};
    F.M=varargin{3};
    
    % Sanitize 'a' and 'M'. Make M a column vector of length N,
    % where N is determined from the length of 'a'
    F.a=F.a(:);
    F.N=numel(F.a);
    F.M=bsxfun(@times,F.M(:),ones(F.N,1));
    
end;

[F.flags,F.kv]=ltfatarghelper({},definput,vargs);

F.type=ftype;
F.origargs=varargin;


%% ------ Post optional parameters

% Default value, works for all bases
F.framered=1;

% Default value, frame works for all lengths
F.framelength=@(Ls) Ls;

switch(ftype)
  case 'gen'
    F.g=varargin{1};
    F.frana=@(insig) F.g'*insig;
    F.frsyn=@(insig) F.g*insig;
    F.framelength = @(Ls) size(F.g,1);
    F.framered = size(F.g,2)/size(F.g,1);
      
  case 'identity'
    F.frana=@(insig) insig;
    F.frsyn=@(insig) insig;
    
  case 'dft'
    F.frana=@(insig) dft(insig,[],1);
    F.frsyn=@(insig) idft(insig,[],1);

  case 'dcti'
    F.frana=@(insig) dcti(insig,[],1);
    F.frsyn=@(insig) dcti(insig,[],1);

  case 'dctii'
    F.frana=@(insig) dctii(insig,[],1);
    F.frsyn=@(insig) dctiii(insig,[],1);

  case 'dctiii'
    F.frana=@(insig) dctiii(insig,[],1);
    F.frsyn=@(insig) dctii(insig,[],1);

  case 'dctiv'
    F.frana=@(insig) dctiv(insig,[],1);
    F.frsyn=@(insig) dctiv(insig,[],1);

  case 'dft'
    F.frana=@(insig) dft(insig,[],1);
    F.frsyn=@(insig) idft(insig,[],1);

  case 'dsti'
    F.frana=@(insig) dsti(insig,[],1);
    F.frsyn=@(insig) dsti(insig,[],1);

  case 'dstii'
    F.frana=@(insig) dstii(insig,[],1);
    F.frsyn=@(insig) dstiii(insig,[],1);

  case 'dstiii'
    F.frana=@(insig) dstiii(insig,[],1);
    F.frsyn=@(insig) dstii(insig,[],1);

  case 'dstiv'
    F.frana=@(insig) dstiv(insig,[],1);
    F.frsyn=@(insig) dstiv(insig,[],1);

  case 'dftreal'
    F.frana=@(insig) fftreal(insig,[],1)/sqrt(size(insig,1));
    F.frsyn=@(insig) ifftreal(insig,(size(insig,1)-1)*2,1)*sqrt((size(insig,1)-1)*2);
    F.framelength=@(Ls) ceil(Ls/2)*2;
    F.framelengthcoef=@(Ncoef) (Ncoef-1)*2;
    F.realinput=1;

  case 'dgt'
    F.frana=@(insig) framenative2coef(F,comp_dgt(insig,F.g,F.a,F.M,F.kv.lt,F.flags.do_timeinv,0,0));
    F.frsyn=@(insig) comp_idgt(framecoef2native(F,insig),F.g,F.a,F.kv.lt,F.flags.do_timeinv,0);    
    F.framelength=@(Ls) dgtlength(Ls,F.a,F.M,F.kv.lt);
    F.framered=F.M/F.a;
    
  case 'dgtreal'
    F.frana=@(insig) framenative2coef(F,comp_dgtreal(insig,F.g,F.a,F.M,F.kv.lt,F.flags.do_timeinv));
    F.frsyn=@(insig) comp_idgtreal(framecoef2native(F,insig),F.g,F.a,F.M,F.kv.lt,F.flags.do_timeinv);  
    F.framelength=@(Ls) dgtlength(Ls,F.a,F.M,F.kv.lt);
    f.framered=F.M/F.a;
    F.framelengthcoef=@(Ncoef) Ncoef/(floor(F.M/2)+1)*F.a;
    
  case 'dwilt'
    F.frana=@(insig) framenative2coef(F,comp_dwilt(insig,F.g,F.M));
    F.frsyn=@(insig) comp_idwilt(framecoef2native(F,insig),F.g);  
    F.framelength=@(Ls) dwiltlength(Ls,F.M);
    
  case 'wmdct'
    F.frana=@(insig) framenative2coef(F,comp_dwiltiii(insig,F.g,F.M));
    F.frsyn=@(insig) comp_idwiltiii(framecoef2native(F,insig),F.g);  
    F.framelength=@(Ls) dwiltlength(Ls,F.M);        
    
  case 'filterbank'
    F.frana=@(insig) framenative2coef(F,filterbank(insig,F.g,F.a));
    F.frsyn=@(insig) ifilterbank(framecoef2native(F,insig),F.g,F.a);
    F.framelength=@(Ls) filterbanklength(Ls,F.a);
    F.framelengthcoef=@(Ncoef) round(Ncoef/sum(1./F.a));
    F.framered=sum(1./F.a);
    
  case 'filterbankreal'
    F.frana=@(insig) framenative2coef(F,filterbank(insig,F.g,F.a));
    F.frsyn=@(insig) 2*real(ifilterbank(framecoef2native(F,insig),F.g, ...
                                        F.a));
    F.framelength=@(Ls) filterbanklength(Ls,F.a);
    F.framelengthcoef=@(Ncoef) round(Ncoef/sum(1./F.a));
    F.framered=2*sum(1./F.a);
    
  case 'ufilterbank'
    F.frana=@(insig) framenative2coef(F,ufilterbank(insig,F.g,F.a));
    F.frsyn=@(insig) ifilterbank(framecoef2native(F,insig),F.g,F.a);   
    F.framelength=@(Ls) filterbanklength(Ls,F.a);
    F.framelengthcoef=@(Ncoef) round(Ncoef/sum(1./F.a));
    F.framered=sum(1./F.a);
    
  case 'ufilterbankreal'
    F.frana=@(insig) framenative2coef(F,ufilterbank(insig,F.g,F.a));
    F.frsyn=@(insig) 2*real(ifilterbank(framecoef2native(F,insig),F.g, ...
                                        F.a));
    F.framelength=@(Ls) filterbanklength(Ls,F.a);
    F.framelengthcoef=@(Ncoef) round(Ncoef/sum(1./F.a));
    F.framered=2*sum(1./F.a);
    
  case 'nsdgt'
    F.frana=@(insig) framenative2coef(F,nsdgt(insig,F.g,F.a,F.M));
    F.frsyn=@(insig) insdgt(framecoef2native(F,insig),F.g,F.a);
    F.framelength=@(Ncoef) sum(F.a);
    F.framelengthcoef=@(Ncoef) sum(F.a);
    F.framered=sum(F.M)/sum(F.a);    
    
  case 'unsdgt'
    F.frana=@(insig) framenative2coef(F,unsdgt(insig,F.g,F.a,F.M));
    F.frsyn=@(insig) insdgt(framecoef2native(F,insig),F.g,F.a);
    F.framelength=@(Ncoef) sum(F.a);
    F.framelengthcoef=@(Ncoef) sum(F.a);
    F.framered=sum(F.M)/sum(F.a);    

  case 'nsdgtreal'
    F.frana=@(insig) framenative2coef(F,nsdgtreal(insig,F.g,F.a,F.M));
    F.frsyn=@(insig) insdgtreal(framecoef2native(F,insig),F.g,F.a,F.M);
    F.framelength=@(Ncoef) sum(F.a);
    F.framelengthcoef=@(Ncoef) sum(F.a);
    F.framered=sum(F.M)/sum(F.a);    
    
  case 'unsdgtreal'
    F.frana=@(insig) framenative2coef(F,unsdgtreal(insig,F.g,F.a,F.M));
    F.frsyn=@(insig) insdgtreal(framecoef2native(F,insig),F.g,F.a,F.M);
    F.framelength=@(Ncoef) sum(F.a);
    F.framelengthcoef=@(Ncoef) sum(F.a);
    F.framered=sum(F.M)/sum(F.a);    
                
  case 'fusion'
    F.w=varargin{1};
    F.frames=varargin(2:end);
    F.Nframes=numel(F.frames);
    F.w=bsxfun(@times,F.w(:),ones(F.Nframes,1));    
    F.framelength = @(Ls) comp_framelength_fusion(F,Ls);
    F.framered=sum(cellfun(@framered,F.frames));
    
    % These definitions binds F itself, so they must execute last
    F.frana=@(insig) comp_frana_fusion(F,insig);
    F.frsyn=@(insig) comp_frsyn_fusion(F,insig);

    
  case 'tensor'
    % This frame type is currently broken. It must be reworked to reshape
    % to the standard layout in order not to break all the assumptions.
    F.frames=varargin;
    F.Nframes=numel(F.frames);
    for ii=1:F.Nframes
        if F.frames{ii}.realinput
            error(['It is not safe to embed a real-valued-input-only frame ' ...
                   'into the tensor frame.']);
        end;
    end;
    
    F.frana=@(insig) comp_frana_tensor(F,insig);
    F.frsyn=@(insig) comp_frsyn_tensor(F,insig);
    
    F.framelength=@(Ls) comp_framelength_tensor(F,Ls);

    F.framered=prod(cellfun(@framered,F.frames));
    
  case {'fwt'}
    F.J=varargin{2};
    F.g=fwtinit(varargin{1});
    F.frana=@(insig) fwt(insig,F.g,F.J);
    F.frsyn=@(insig) ifwt(insig,F.g,F.J,size(insig,1));
    F.framelength=@(Ls) fwtlength(Ls,F.g,F.J);
    
  otherwise
    error('%s: Unknows frame type: %s',upper(mfilename),ftype);  

end;

% This one is placed at the end, to allow for F.framered to be defined
% first.
if ~isfield(F,'framelengthcoef')
    F.framelengthcoef=@(Ncoef) Ncoef/framered(F);
end;
